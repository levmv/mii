# Blocks

* /mii/web/Blocks
* /mii/web/Block

Blocks – это система организации шаблонов и ресурсов проекта (всего того, что относится к frontend).
Шаблоны представляют собой традиционные php-шаблоны. Под ресурсами в данном случае понимаются js, css файлы (для них
специальная обработка) и любые другие файлы (изображения, swf, etc).
В основе лежит идея, что интерфейс любого сайта можно представить в виде набора независимых блоков.

Blocks это:

* соглашение об именовании и организации файлов
* традиционные php шаблоны
* механизм автоматической сборки ресурсов

Как выглядит традиционные системы шаблонов и организации ресурсов в php-проектах? Ну, наверное, как-то так:
```php
$assets->add_css('path/to/file.css');
$assets->add_css('path/to/another/file.css');
$assets->add_js('path/to/script.js');

$template = new Template('path/to/template');
$template->set(something);
$template->render()
```

Единственная связь ресурсов с шаблонами в этом случае — это разве что вызов ```$assets->render_includes()``` где-нибудь
в теле шаблона.

Blocks схож с подобными системами в том смысле, что он тоже умеет управляет ресурсами в реал-тайм. Список используемых в текущий
момент ресурсов строится в реальном времени.

Ключевое отличие Blocks — наличие методологии.


#### Именование блоков
Обращение к блоку производится по его имени. Блоки могут быть вложены в другие, что отражается в их имени.
К примеру, блок foo_bar вложен в блок foo. На уровне файловой системы символ подчеркивания заменяется слэшем.
Поэтому директория блока foo_bar будет `/foo/bar/`
При этом полный путь к файлу шаблонов будет таким: `/foo/bar/foo_bar.php`, к файлу стилей `/foo/bar/foo_bar.css`, к js файлу,
соответственно, `/foo/bar/foo_bar.js`.

Понятие «вложенный блок» довольно условно. Кроме физического расположения такие блоки могут быть ничем больше не связаны
(Но, на практике, конечно, вложенные блоки всегда логически/семантически связаны с родительским блоком).

Стоит избегать излишней вложенности. Нет ничего страшного в определенном упрощении структуры. Вложенность больше 3х уровней приводит к
не слишком удобным длинным идентификаторам.

#### Блок и работа с ним

Обращение к блоку осуществляется следующим образом: ```Blocks::get(имя блока);``` (а точнее: ```Mii:$app->blocks()->get(имя блока)```), 
но на практике всегда используется краткий алиас ```block(имя блока);```

Основные методы работы с блоком:

- ```set($name, $value)``` установка переменных блока. Может быть передана пара имя-значения или ассоциативный массив
- ```bind($name, $value)``` аналог set, но установливается не значение, а ссылка
- ```get($name)``` получение значения переменной
- ```render($force = false)``` рендеринг шаблона. По умолчанию шаблон не будет отрендерен, если до этого не была установлена ни одна переменная. Флаг force включает рендеринг в любом случае.
- ```depends([dep1, dep2, ...])``` список зависимых блоков, которые необходимо подключить

Также допустима установка/получение переменных прямым обращением:
```
block('имя блока')->foo = 'bar';
echo block('имя блока')->foo;
```
Этот код выведет строку ```bar```

Код ```echo block('имя блока');``` эквивалентен ```echo block('имя блока')->render();```

#### CSS, js

Каждый блок может содержать css и js файлы. При этом, правильным способом работы является использование уникальных имен классов/переменных.
Название всех css-классов лучше начинать с имени самого блока. Код в js файлах — оборачивать в объект с именем блока.
(Впрочем, это лишь соглашение. Никаких физических ограничений на содержимое нет).

css и js файлы будут автоматически подключены к проекту при любом вызове блока в коде (даже в том случае, если он фактически не рендерится).

Файлы автоматически копируются в директорию указанную в опции base_path. В зависимости от настроек или по отдельности, или склеиваются в один файл (по имени блока).

Конечно же, файлы не копируются каждый раз — проверяется дата изменения файла (если хотя бы один файл в одном из блоков изменен позже,
чем итоговый файл, то произойдет пересборка).


#### Сеты

Все ключевые настройки Blocks организуются в «сет». Сетов может быть много и каждый сет имеет свое имя. Сет по-умолчанию
имеет имя default. 

Установить конкретный сет как основной можно методом Blocks->load_set(<имя сэта>);

По-сути сет это просто именованный массив настроек для Blocks. 

#### Библиотеки блоков

По умолчанию все блоки лежат в директории @app/blocks. И это является дефолтной библиотекой блоков.
Библиотека может обладать любым путем (т.е. не обязательно директория blocks. Можно назвать bloxs и положить куда угодно).
Библиотек может быть больше, чем одна. В таком случае нужный блок ищется по очереди в каждой библиотеке блоков (в порядке их подключения).
*Так например, можно добавить библиотеку для мобильной версии сайта и поставить ее первой. И, в случае, если содержимое шаблона 
едино для обоих версий, менять только css. В таком случае система возьмет css файл блока в первой библиотеке, а шаблон из следующей.*


#### Ручная сборка

В целях оптимизации есть возможность отключить автоматическую сборку полностью, используя опцию use_static = true.
В конфигурации компонента нужно указать ревизию и руками указать имена файлов и список блоков, из которых они должны быть собраны.


Например, прописываем в конфиге:
```php
[
    'revision' => '1',
    'static' => 
        'layout' => [
            'css' => [
                'i_base', 'header', 'sidebar'
            ],
            'js' => [
                'i_jquery', 'sidebar'
            ]
        ]
        
    ],
]
```
Важный момент в том, что один блок может быть указан только для сборки одного файла. 

Запускаем билдер (mii assets) и получаем файлы layout.css и layout.js, собранные из соответствующих блоков. Никакой постобработки
содержимого файлов не делается, но сборщик проверяет наличии файла assets.js в корне проекта и если он есть, запускает его
через node.js и передает в него список файлов. 
Таким же образом сборщик может автоматически инкрементить номер ревизии. Достаточно вынести ее в отдельный конфиг вида:
```php
<?php return 1;
```
и положить в корень проекта под именем revision.php. 


Сборщик читает конфигурацию Blocks и собирает блоки для всех сетов сразу.
По умолчанию каждый сет используют список файлов загружаемый из опции 'static'. Но можно поместить список файлов
в другую переменную и указать её имя в сете в опции 'static_source'.
```php
'sets' => [
    'mobile' => [
        'libraries' => [
            '@app/blocks_mobile',
            '@app/blocks'
        ],
        'base_url' => '/assets/m'
        'static' => 'mobile'
    ],
],
'mobile' => [
    'layout' => [
        'css' => [
            'i_base', 'header', 'sidebar'
        ],
        'js' => [
            'i_jquery', 'sidebar'
        ]
    ]
]
```

#### Подключение css/js

Получить список текущих подключенных css и js файлов можно вызовами ```Mii::$app->blocks()->css``` и ```Mii::$app->blocks()->js()```
Данная функция возвращает список script и style тэгов для подключения соответствующих файлов.
Обычно используется в базовом блоке index:

````php
<head>
    <?= Mii::$app->blocks()->css() ?>
    <?= Mii::$app->blocks()->js() ?>
</head>
````

Для корректной работы необходимо, что бы вызов этих методов был после всех обращений к другим блокам. Обычно это реализуется выводом базового блока
index в методе after и отсутствием прямых обращений к другим блокам в самом index.


#### assets
В директории любого блока может находится поддиректория assets. Содержимое этой директории без изменений 
копируется в директорию /assets/имя блока/ в публичной части сайта (или другое место. задается переменными base_dir и base_url в конфиге).


#### Конфигурация

Простая (указаны дефолтные значения):

```php

    'blocks' => [
        'libraries' => [   // пути к библиотекам блоков
            '@app/blocks'  
        ],
        'merge' => true, // склеивать ли css (или js) файлы между собой или нет в динамическом режиме
        'use_static' => false,  
        'base_path' => '@app/assets', // абсолютный путь к директории, куда копируются обработанные ресурсы
        'base_url' => '/assets' // url-путь относительно корня или полный url (обычно, если выносим ресурсы на поддомен)
        'revision' => '1', // номер ревизии, для использования в static режиме
    ],
```    

C cетами и static режимом:

```php

    
'blocks' => [
    'revision' => '7',

    'base_url' => '/assets/d',

    'sets' => [
        'default' => [
            'libraries' => [
                '@app/blocks'
            ],
            'base_url' => '/assets/d'
        ],
        'mobile' => [
            'libraries' => [
                '@app/blocks_mobile',
                '@app/blocks'
            ],
            'base_url' => '/assets/m'
        ],
        'admin' => [
            'libraries' => [
                '@app/blocks_admin'
            ],
            'base_url' => '/assets/a'
        ]
    ],

    'static' => [

        'about' => ['css' => 'about'],

        'layout' => [
            'css' => 'layout',
            'js' => 'layout'
        ],
    ],
    'admin' => [
        'layout' => [
                'css' => 'layout',
                'js' => 'layout'
        ],
    ]
```   




